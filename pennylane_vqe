# -*- coding: utf-8 -*-
"""Molecular_quantum_chem_Pennylane_AI.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JH49kH5QUF0oHZ8T5_aRIoKXY7OFlDgU
"""

#Install packages for Quantum Computing for VQE
!!pip install pennylane

#Pennylne has the VQE function for finding the ground-state energy of a molecule using a hydroxide ion example

import pennylane as qml
from pennylane import numpy as np

#Assign coordinates for the hydroxide by picking a center atom (most electrons to share)
symbols = ["H", "O"]
coords = np.array([[0.0, 1.0, 0.0], [0.0, 0.0, 0.0]])

#Install pyscf plugin for the electronic structure package to interface with OpenFermion.
!pip install openfermionpyscf

# Build the qubit Hamiltonian for the molecule with the Quantum Chem package from Pennylane
# The Hamiltonian equation will describe the energy state to minimize with the VQE library 
from pennylane import qchem
hamiltonian, qubits = qml.qchem.molecular_hamiltonian(symbols, coords, charge=-1, method='pyscf')
print(hamiltonian)

#Get the total spin for the moelcule with 10 electrons and the Hamiltonian equation
electrons = 10  # Hydroxide ion has ten electrons

S2 = qchem.spin2(electrons, qubits)
print(S2)

# Set the backend for the energy minimization computation to the Pennylane AI simulator
dev = qml.device("lightning.qubit", wires=qubits)


# Start with the initial guess at a trial wavefunction (Ansatz) that will provide an energy. Create the Quantum circuit (Ansatz) defined in this literature link https://arxiv.org/abs/2106.13840
# Use the Hartree-Fock state originally used on the H2 molecule
hf_state = qchem.hf_state(electrons, qubits)
# generate single- and double-excitations
singles, doubles = qchem.excitations(electrons, qubits)

# The circuit In Pennylane is to compute the expectation value of the molecular Hamiltonian in the trial state wavefunction
def circuit(params, wires):
    qml.templates.AllSinglesDoubles(params, wires, hf_state, singles, doubles)

wires = dev.wires.tolist()


@qml.qnode(dev)
def energy_expval(params):
    circuit(params, wires)
    return qml.expval(hamiltonian)


@qml.qnode(dev)
def S2_expval(params):
    circuit(params, wires)
    return qml.expval(S2)

#Alternatively, also  set up a hybrid job on AWS Braket, their quantum computing service
#from braket.jobs import InstanceConfig, hybrid_job
#from braket.tracking import Tracker

#large_instance = InstanceConfig(instanceType="ml.c5.xlarge")


#@hybrid_job(
#    device="local:pennylane/lightning",
#    instance_config=large_instance,
#)

#Remove the comments one you set up the service on AWS to try this out

#Use a random number generator to get the initial parameters including spin
np.random.seed(1967)
params = np.random.normal(0, np.pi, len(singles) + len(doubles))

def spin(params):
    return -0.5 + np.sqrt(1 / 4 + S2_expval(params))

print("Energy:", float(energy_expval(params)))
print("Spin:  ", float(spin(params)))

# For this run use the classical ML minimizer in Pennylane RMSPropOptimizer.
# Check out other alternatives: GradientDescentOptimizer, AdagradOptimizer, AdamOptimizer, ...
opt = qml.RMSPropOptimizer(stepsize=0.2)

#You can pick a higher number or lower number of iterations
iterations = 22

import time

#from braket.jobs.metrics import log_metric


def run_vqe(energy_expval, spin, opt, initial_params, iterations):
    energies = []
    spins = []
    params = initial_params

    start = time.time()
    for i in range(iterations):
        params = opt.step(energy_expval, params)

        e = energy_expval(params)
        s = spin(params)

        energies.append(e)
        spins.append(s)

        #log_metric(metric_name="energy", value=e, iteration_number=i)

        print(f"Completed iteration {i + 1}")
        print("Energy:", e)
        print("Total spin:", s)
        print("----------------")

    print(f"Optimized energy: {e} Ha")
    print(f"Corresponding total spin: {s}")
    print(f"Elapsed: {time.time() - start} s")
    return energies, spins

#Run the computation to see what energy value it  converges to
energies, spins = run_vqe(energy_expval, spin, opt, params, iterations)

#This can also be plotted using MatplotLib to view the final state
